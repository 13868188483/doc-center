1 **持久化类的规则：持久化----内存里面的数据到数据库！**

2 **持久化类：java类和table建立映射关系，一个java类有映射文件，**

3 **编写规则：无参的构造（用到了反射，底层），第二：属性私有，提供get和set方法，第三：唯一标识oid和数据库的主键对应，（区分唯一，是不是同一记录），第四：尽量使用包装类，（因为基本默认是0，就会有很多的歧义，比如工资：一天没来，是0，请假了也是0，没有插入也是0，很难区分，包装类是null,第五：持久化的类不要final修饰（延迟加载：hibernate的优化机制，load方法会继承，底层代理对象，延迟失效，不能优化！！！立刻加载，真实的对象，和get一样））**

# 1 主键生成策略：

1 **主键的分类：是约束，第一：自然主键------就是主键的本身，表里面的字段，实体的具体的属性，比如人员的身份证号，身份证号作为主键是唯一的，不可重复的，学号比如！！！第二：代理主键，不是实体的某个具体的属性，比如人员表----不是表里面的字段（不是实体的属性！），开发尽量使用代理主键！！！！原因：自然的主键参与代码，后期会修改源代码，好的设计满足ocp,扩展是开放的，源码是封闭的，主键是不可以修改的，整个的设计都要修改，代理和表没有关系，**

2 **一般不允许用户自己手动的设置：第一：increment自动的增长，hibernate的机制，生成的表，结构没有increment!!!update有increment！！！short,int,long。字符串不可以！多线程不可以！首先select max(id) from 然后加一！！！多线程不安全！，第二：identity自动的增长，short,int,long,底层增长，mysql,sqlserver,oracle不可以自动的增长，是序列的增长，oracle不可以用。   第三：sequence:序列，short,int,long,oracle支持可以的，mysql不可以的！！！第四：uuid字符串类型的是可以的，随机的字符串！！！第五：native本地策略，identity和sequence自动的运行切换，mysql和oracle自动的切换，第六：assigned:hibernate放弃主键维护，自己管理，手动！！！**

2 ##三种状态

1 **知道就好了，持久化类就是java类和table建立了映射关系，第一：瞬时态------没有唯一的oid标识，sessoin没有管理第二：持久态：oid有被session管理，第三：托管态：oid有，session没有管理，（提交，关闭！session销毁了，）**

2 **转换：瞬时态：new对象，可以状态的转换，瞬时------持久态（saveOrUpdate()方法和save()方法）也可以托管态（就缺个oid,可以设置一个oid就是托管态的对象）-------------持久态对象：查询一下，get和load()方法就好了，还有find()，iterate(),--------------持久到瞬时：delete()方法，-------session的close()或者clear(),evict()是清空一个！！！-------托管态对象：new一下，设置id就是托管的了！！！托管---持久（update()，saveOrUpdate()方法，）----托管---瞬时：把id为空！！！**

3 **不影响开发，只是为了更深入的理解！！！了解就行！**

4 **持久态对象核心：可以自动的更新数据库，很智能！！！底层原理依赖了一级缓存！！！**

## 3 一级缓存

1 **缓存：一种优化的方式，好处：数据放在内存里面，下一次直接在内存里面拿，不用存储源（db,硬盘），很多的优化手段：提供了两种机制：一级 和二级缓存，一级缓存就是session级别低的缓存，声明周期和session是一致的，石油sesson一系列的集合创建的，她是自带的不可以卸载，二级缓存是sessonFactory需要配，默认不开启的，一般不用了，redis替代！！！session缓存是一块内存空间，java集合，session级别的，get(),load(),list()都会判断缓存司法存在，没有在查询！！！**

4 **一级缓存的快照区：拍的照片，下一次在看不一样，因为对比，数据快照，备份，提交的时候会比较是否更新！！！sesson是接口，实现类是impl,**

5 **事务的回顾：逻辑的一组操作，要么同时成功，同时失败，：原子型--事务不可分割，，一致性，隔离型，持久性， 不考虑隔离型会安全问题，脏读.....幻读....**



6 **解决：设置事务地隔离级别：四种隔离级别，readUncommit,readCommit,repeatable,seriable序列化，排队，不会并发级别最高，效率最低，oracle第二种，mysql第三种。。。。。。**

7 **线程绑定的session:事务一般在service层，为什么？？？三层！dao对数据源的单独操作，比如转账service调用多个dao完成一个业务，threadLocal:绑定线程对象，同一个线程，dao通过当前的线程，同一个链接对象，hibernate已经绑定好了！！！sessionfactory绑定好了！！！**

8 **其他的api:query,sqlQuery**





